import { initializeApp, getApps, FirebaseApp } from 'firebase/app';
import { getAuth, Auth } from 'firebase/auth';
import { getFirestore, Firestore } from 'firebase/firestore';

interface FirebaseServices {
  app: FirebaseApp;
  auth: Auth;
  db: Firestore;
}

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Dev-only diagnostics: Log which env vars are present (never logs actual values)
if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
  console.log('[Firebase] Environment variables check:');
  console.log('  NEXT_PUBLIC_FIREBASE_API_KEY:', !!firebaseConfig.apiKey, firebaseConfig.apiKey?.length || 0, 'chars');
  console.log('  NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN:', !!firebaseConfig.authDomain);
  console.log('  NEXT_PUBLIC_FIREBASE_PROJECT_ID:', !!firebaseConfig.projectId);
  console.log('  NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET:', !!firebaseConfig.storageBucket);
  console.log('  NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID:', !!firebaseConfig.messagingSenderId);
  console.log('  NEXT_PUBLIC_FIREBASE_APP_ID:', !!firebaseConfig.appId);
}

// Helper function to validate env vars (called when Firebase is actually used, not at import)
function validateFirebaseConfig(): void {
  const requiredEnvVars: (keyof typeof firebaseConfig)[] = [
    'apiKey',
    'authDomain',
    'projectId',
    'storageBucket',
    'messagingSenderId',
    'appId',
  ];

  const missing: string[] = [];
  for (const envVar of requiredEnvVars) {
    if (!firebaseConfig[envVar]) {
      const envName = `NEXT_PUBLIC_FIREBASE_${envVar.toUpperCase().replace(/([A-Z])/g, '_$1')}`;
      missing.push(envName);
    }
  }

  if (missing.length > 0) {
    console.error('[Firebase] Missing environment variables:', missing);
    if (typeof window !== 'undefined') {
      // Only show error in browser (not during SSR)
      console.error(
        '\nMissing Firebase environment variables:\n' +
        missing.map(v => `  - ${v}`).join('\n') +
        '\n\nPlease add these to your .env.local file and restart the dev server.'
      );
    }
    throw new Error(
      `Missing Firebase environment variables: ${missing.join(', ')}`
    );
  }
}

// Initialize Firebase (singleton pattern to prevent multiple initializations)
let _app: FirebaseApp | null = null;
let _auth: Auth | null = null;
let _db: Firestore | null = null;

function initializeFirebaseApp(): FirebaseApp {
  // Validate env vars when Firebase is actually initialized
  validateFirebaseConfig();

  const apps = getApps();
  if (apps.length > 0) {
    if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
      console.log('[Firebase] Using existing Firebase app instance');
    }
    return apps[0]; // Return existing app if already initialized
  }

  if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
    console.log('[Firebase] Initializing new Firebase app with projectId:', firebaseConfig.projectId);
  }

  return initializeApp(firebaseConfig);
}

// Lazy initialization - only initialize when actually used
export function getFirebaseApp(): FirebaseApp {
  if (!_app) {
    _app = initializeFirebaseApp();
  }
  return _app;
}

export function getFirebaseAuth(): Auth {
  if (!_auth) {
    const app = getFirebaseApp();
    _auth = getAuth(app);
    if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
      console.log('[Firebase] Auth instance created');
    }
  }
  return _auth;
}

export function getFirebaseDB(): Firestore {
  if (!_db) {
    const app = getFirebaseApp();
    _db = getFirestore(app);
    if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
      console.log('[Firebase] Firestore instance created');
    }
  }
  return _db;
}

// Export services as a single object for convenience
export const services: FirebaseServices = {
  get app(): FirebaseApp { return getFirebaseApp(); },
  get auth(): Auth { return getFirebaseAuth(); },
  get db(): Firestore { return getFirebaseDB(); },
};

// Backwards compatible exports - create real instances instead of Proxy
// The Proxy approach can cause issues when Firebase SDK needs to check instance properties
let authInstance: Auth | null = null;
let dbInstance: Firestore | null = null;

export const auth = new Proxy({} as Auth, {
  get(target, prop) {
    if (!authInstance) {
      authInstance = getFirebaseAuth();
    }
    return authInstance[prop as keyof Auth];
  },
  set(target, prop, value) {
    if (authInstance) {
      (authInstance as any)[prop] = value;
    }
    return true;
  },
  has(target, prop) {
    return prop in getFirebaseAuth();
  },
  ownKeys() {
    return Object.keys(getFirebaseAuth());
  },
});

export const db = new Proxy({} as Firestore, {
  get(target, prop) {
    if (!dbInstance) {
      dbInstance = getFirebaseDB();
    }
    return dbInstance[prop as keyof Firestore];
  },
  set(target, prop, value) {
    if (dbInstance) {
      (dbInstance as any)[prop] = value;
    }
    return true;
  },
  has(target, prop) {
    return prop in getFirebaseDB();
  },
  ownKeys() {
    return Object.keys(getFirebaseDB());
  },
});

export default getFirebaseApp();
